/**
 * @file Observation.cpp
 * @author  Scott Rasmussen (scott.rasmussen@zaita.com)
 * @version 1.0
 * @date 6/03/2013
 * @section LICENSE
 *
 * Copyright NIWA Science ï¿½2013 - www.niwa.co.nz
 *
 * $Date: 2008-03-04 16:33:32 +1300 (Tue, 04 Mar 2008) $
 */

// Headers
#include "Observation.h"

#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/trim_all.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/join.hpp>

#include "Categories/Categories.h"
#include "Likelihoods/Manager.h"
#include "Model/Managers.h"
#include "Model/Model.h"
#include "../Utilities/Math.h"

// Namespaces
namespace niwa {

/**
 * Default Constructor
 */
Observation::Observation(shared_ptr<Model> model) : model_(model) {
  parameters_.Bind<string>(PARAM_LABEL, &label_, "The label of the observation", "");
  parameters_.Bind<string>(PARAM_TYPE, &type_, "The type of observation", "");
  parameters_.Bind<string>(PARAM_LIKELIHOOD, &likelihood_type_, "The type of likelihood to use", "");
  parameters_.Bind<string>(PARAM_CATEGORIES, &category_labels_, "The category labels to use", "", true);
  parameters_.Bind<Double>(PARAM_DELTA, &delta_, "The robustification value (delta) for the likelihood", "", utilities::math::DELTA)->set_lower_bound(0.0);
  parameters_.Bind<string>(PARAM_SIMULATION_LIKELIHOOD, &simulation_likelihood_label_, "The simulation likelihood to use", "", "");
  parameters_.Bind<Double>(PARAM_LIKELIHOOD_MULTIPLIER, &likelihood_multiplier_, "The likelihood score multiplier", "", Double(1.0))->set_lower_bound(0.0);
  parameters_.Bind<Double>(PARAM_ERROR_VALUE_MULTIPLIER, &error_value_multiplier_, "The error value multiplier for likelihood", "", Double(1.0))->set_lower_bound(0.0);

  mean_proportion_method_ = true;
}

/**
 * Validate the parameters passed in from the
 * configuration file
 */
void Observation::Validate() {
  LOG_TRACE();
  parameters_.Populate(model_);
  LOG_FINEST() << "validating obs " << label_ << " of type = " << type_;

  if (model_->run_mode() == RunMode::kSimulation) {
    if (likelihood_type_ == PARAM_PSEUDO) {
      likelihood_type_ = simulation_likelihood_label_;
    } else {
      simulation_likelihood_label_ = likelihood_type_;
    }
  }

  /**
   * Because this observation supports categories that are provided in groups
   * (using the + operator) we need to verify the number of selectivities
   * matches the true number of categories
   *
   * The number of selectivities can be either the number of true categories
   * or the number of defined collections
   */
  expected_selectivity_count_ = 0;
  Categories* categories = model_->categories();
  for (const string& category_label : category_labels_)
    expected_selectivity_count_ += categories->GetNumberOfCategoriesDefined(category_label);

  LOG_FINEST() << "Expected Selectivity count = " << expected_selectivity_count_;
  DoValidate();
}

/**
 * Build all of the runtime relationships required for
 * this observation
 */
void Observation::Build() {
  LOG_TRACE();

  likelihood_ = model_->managers()->likelihood()->GetOrCreateLikelihood(model_, label_, likelihood_type_);
  if (!likelihood_) {
    LOG_FATAL_P(PARAM_LIKELIHOOD) << "(" << likelihood_type_ << ") was not found or could not be constructed.";
    return;
  }
  likelihood_->set_multiplier(likelihood_multiplier_);
  likelihood_->set_error_value_multiplier(error_value_multiplier_);
  if (std::find(allowed_likelihood_types_.begin(), allowed_likelihood_types_.end(), likelihood_->type()) == allowed_likelihood_types_.end()) {
    string allowed = boost::algorithm::join(allowed_likelihood_types_, ", ");
    LOG_FATAL_P(PARAM_LIKELIHOOD) << ": likelihood " << likelihood_->type() << " is not supported by the " << type_ << " observation."
        << " Allowed types are: " << allowed;
  }

  DoBuild();
}

/**
 * Reset the observation so it can be called again
 */
void Observation::Reset() {
  comparisons_.clear();
  scores_.clear();

  DoReset();
}

/**
 * Save the comparison for an observation to the list of comparisons.
 * Each comparison contributes part to a score and those parts will be stored for reporting.
 *
 * @param category The name of the comparison
 * @param age The age of the population being compared
 * @param length The length of the population being compared
 * @param expected The value generated by the model
 * @param observed The value passed in from the configuration file
 * @param process_error The process error value for this comparison
 * @param error_value The error value passed in from the configuration file
 * @param adjusted_error The distribution-specific combination of error_value and process_error
 * @param delta The delta value passed in from the configuration file
 * @param score The amount of score for this comparison
 */
void Observation::SaveComparison(string category, unsigned age, Double length, Double expected, Double observed,
                                 Double process_error, Double error_value, Double adjusted_error, Double delta, Double score) {
  observations::Comparison new_comparison;
  new_comparison.category_       = category;
  new_comparison.age_            = age;
  new_comparison.length_         = length;
  new_comparison.expected_       = expected;
  new_comparison.observed_       = observed;
  new_comparison.process_error_  = process_error;
  new_comparison.error_value_    = error_value;
  new_comparison.adjusted_error_ = adjusted_error;
  new_comparison.delta_          = delta;
  new_comparison.score_          = score;
  comparisons_[model_->current_year()].push_back(new_comparison);
}

/**
 * Save the comparison for an observation to the list of comparisons.
 * Each comparison contributes part to a score and those parts will be stored for reporting.
 *
 * @param category The name of the comparison
 * @param expected The value generated by the model
 * @param observed The value passed in from the configuration file
 * @param process_error The process error value for this comparison
 * @param error_value The error value for this comparison
 * @param adjusted_error The distribution-specific combination of error_value and process_error
 * @param delta The delta value passed in from the configuration file
 * @param score The amount of score for this comparison
 */
void Observation::SaveComparison(string category, Double expected, Double observed,
                                 Double process_error, Double error_value, Double adjusted_error, Double delta, Double score) {
  SaveComparison(category, 0, 0, expected, observed, process_error, error_value, adjusted_error, delta, score);
}

} /* namespace niwa */

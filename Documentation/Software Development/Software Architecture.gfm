CASAL2

Software Architecture

v2016.1

Author:

Scott Rasmussen

Zaita

scott.rasmussen@zaita.com

# <span id="anchor"></span>Document History

|         |                                                         |             |            |
| ------- | ------------------------------------------------------- | ----------- | ---------- |
| 1.0     | Initial version - Draft                                 | S.Rasmussen | 13/06/2012 |
| 1.1     | Modification of diagrams, explanation of states         | S.Rasmussen | 12/07/2012 |
| 1.2     | Updating diagram to show modifications to states        | S.Rasmussen | 28/02/2013 |
|         | Updating Development environment                        |             |            |
| 1.3     | Update to show functionality created as part of phase 1 | S.Rasmussen | 05/07/2013 |
| V2016.1 | Update to reflect released version 1.0 of CASAL2        | S.Rasmussen | 20/01/2016 |

# <span id="anchor-1"></span>CASAL2 Overview

CASAL2 is the successor to the CASAL modelling application that was
developed approximately 10 years ago. It has been developed using modern
technology and current best practice development techniques to ensure
maintainability and integrity.

CASAL2's architect is based on the design mentality behind the Spatial
Population Model (SPM -
<http://www.niwa.co.nz/fisheries/tools-resources/spm-spatial-population-model>
). The code base is highly modular with code developed in small
light-weight objects that are easily recognisable and extensible.

The SPM code base was developed in 2007 and is still maintainable today
as the code follows a well documented coding standard and a simplistic
layout for objects. The techniques used to develop SPM are proven, and
have been applied to the development of CASAL2.

# <span id="anchor-2"></span>Supported Operating Systems

CASAL2 is as a native 64 bit (x64) application with no 32 bit (x86)
support.

The processor families supported are the Intel and AMD processors that
conform to the AMD64 (x64) specification. PowerPC and ARM processors are
not supported.

Operating Systems supported will be Windows 7/8/10 (64 bit) and Linux
(64 bit). All other Operating System variants (BSD, Unix, OSX, Android,
IOS) may work, but have not been tested.

# <span id="anchor-3"></span>Development Environment

# <span id="anchor-4"></span>CASAL2 will primarily be developed on:

## <span id="anchor-5"></span>Operating Systems

  - # Microsoft Windows 7 (x64)

  - # Microsoft Windows 10

  - # OpenSuSe 12.2 (Mantis x64)

  - # OpenSuSe Tumbleweed (bleeding edge rolling releases)

  - # Ubuntu 15.10

#

## <span id="anchor-6"></span>Development Environment

The environments listed below contain the compatable versions. Any
versions of software not listed below are most likely not compatable
with CASAL2.

The G++ compiler must be atleast version 4.8 to work. Anything newer
than this should work fine.

### <span id="anchor-7"></span>Windows

  - # TDM-GCC 4.8.X (<http://tdm-gcc.tdragon.net/> )

  - # <span id="anchor-8"></span>TDM-GCC 4.9.X (<http://tdm-gcc.tdragon.net/> )

  - # TDM-GCC 5.0.X (<http://tdm-gcc.tdragon.net/> )

  - # TDM-GCC 5.1.X (<http://tdm-gcc.tdragon.net/> )

  - # TDM-GFortran

  - # AQTime3 – Performance profiling

  - # Very Sleepy – Performance profiling

#

# CASAL2 comes with components as part of it's build system. These are:

  - # Unix Utils - \*nix command line applications for Windows

  - # Python 2.X

  - # CMake 2.8.X

### <span id="anchor-9"></span>Linux

  - # <span id="anchor-10"></span>GCC/G++ 4.8.X

  - # GCC/G++ 4.9.X

  - # GCC/G++ 5.0.X

  - # GCC/G++ 5.1.X

  - # GCC/G++ Fortran

  - # Valgrind

  - # CMake 2.8.X+

  - # Python 2.X (not 3.X or 4.X)

  - # Python dateutil, datetime, re, distutils modules

### <span id="anchor-11"></span>Both

  - # <span id="anchor-12"></span>Eclipse (<http://www.eclipse.org/> )

    #

## <span id="anchor-13"></span>Coding Style

# While it's going to be a step away from the style used for SPM, CASAL2 will use the Google Coding style (<http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml> ). Google provides a handy script to parse source code and highlight errors that do not match their coding style.

#

# Spelling of variable names, classes etc will all be done using British English.

#

# Note: The only deviation from this style is the use of \*.cpp instead of \*.cc for filename extensions.

# <span id="anchor-14"></span>High-Level Design

## <span id="anchor-15"></span>Level 0 Data-Flow-Diagram

![](images/input_output.png)

## <span id="anchor-16"></span>State-Transition Diagram

![](images/state_order.png)

# <span id="anchor-17"></span>State Descriptions

## <span id="anchor-18"></span>StartUp

The model is in the blank start and the configuration system is loading
the configuration files and parsing any extra inputs.

Tasks completed:

  - Parse command line
  - Parse configuration file
  - Load plugins
  - Load estimate values from input files

## <span id="anchor-19"></span>Validate

All user configurations have been loaded at this point. Now the model
will go through every object that has been created and check that the
parameters given to them.

This step will ensure every object in the model has sufficient
parameters to be executed without causing a system fault or error in the
model.

This state will not check the values to ensure they are logical in
relation to an actual model. They will only test that they exist and
meet minimum requirements to execute a model.

At the end of the validate stage each object should be internally
consistent. No lookups or external references are allowed to be formed
during this stage.

## <span id="anchor-20"></span>Build

The build phase is where the system will build relationships between
objects that rely on each other. Because validation has been completed,
each object in it's self-contained configuration is ok.

This phase generally assigns values to pointers for objects so they
don't need to do lookups of objects during execution phases.

## <span id="anchor-21"></span>Verify

At this point pre-defined configurations are checked against the model's
current configuration to verify if the model makes sense logically.
These are business rules being applied to the model to help ensure the
output is not garbage.

Note: This state is not executed by default and must be defined as part
of the model execution.

Note: This has not been implemented.

## <span id="anchor-22"></span>PreExecute

Pre-Execution happens at the beginning of a time step. This allows
objects to calculate values based on the partition state before any of
the other processes in the time step are executed.

## <span id="anchor-23"></span>Execute

This is the general work method of the model and where all of the
processes will be run against the partition.

## <span id="anchor-24"></span>PostExecute

This is executed at the end of a time step after all of the processes
and associated objects have been executed. This is typically used for
things like reports and derived quantities.

## <span id="anchor-25"></span>IterationComplete

This is executed at the end of every model run. This is only useful when
the model is in a multiple-iteration mode (e.g MCMC or Estimation).
After every model iteration this state is triggered.

## <span id="anchor-26"></span>Reset

If the model has to run multiple iterations then the reset state is used
to reset everything back in to a state where the model can be
re-executed without any legacy data remaining.

This state allows us to run multiple iterations of the model without
having to re-process the configuration information or
de-allocate/re-allocate large amounts of memory.

## <span id="anchor-27"></span>Finalise

Finalise will happen after all iterations of the model have been
completed.

# <span id="anchor-28"></span>Software Components

## <span id="anchor-29"></span>Utilities Library

Inside CASAL2 is a collection of re-usable methods for reading the
command line, converting between types, using auto-differentiation
types, logging, error handling, double comparison etc.

While not a stand-alone library these methods can easily be extracted
for use within other NIWA projects.

## <span id="anchor-30"></span>Configuration File Parser

The configuration parser was developed from the ground up as a new
component for CASAL2 using ideas inspired by the SPM implementation.
While it's not a stand-alone component it is still in a state that
allows it to be easily ported to other applications.

Some of the in-built functionality of the configuration file parser is a
“parameters” architecture that allows for quick retrieval and validation
of user supplied parameters with type-conversions and validations. The
configuration parser also has the ability to track what file and line a
particular parameter was defined to be used for error reporting.

Note: it is expected that SPM will move to the same coding standard as
CASAL2 in the future and one of the first components that will make a
migration back from CASAL2 will be the configuration parsing system.

## <span id="anchor-31"></span>Minimisers

CASAL2 supports multiple minimisers out of the box.

  - ADOL-C (Auto Differentiation)
  - BetaDiff (Auto-Differentiation)
  - CppAD (Auto-Differentiation)
  - GammaDiff / Numerical Differences
  - DESolver – Differential Evolutionary Solver
  - DLib

Adding new minimisers is quite simple. Adding new minimisers that are
auto differentiation minimisers is significantly more complex, but still
a relatively simple task.

#

# <span id="anchor-32"></span>Plugin Architecture

No plugin architecture has been developed. However adding the ability to
have objects loaded from shared libraries at runtime would be a simple
task. The main components of CASAL2 are already loaded like this, so
there is a heap of template code in the FrontEnd application.

## <span id="anchor-33"></span>Dynamic-Library

Developers with enough competence in C++ will be able to develop and
load their own plugins by building shared-libraries and specifying the
location of these within their configuration files.

An expected inclusion section of someone's plugin would be:

\#include \<niwa/CASAL2/process.h\>

\#include \<niwa/CASAL2/selecvity.h\>

class myNewProcess : public niwa::CASAL2::process {

public:

void validate() { }

void build() { }

void execute() { }

}

*Difficulty for user to develop:* High

*Execution speed:* Fast

## <span id="anchor-34"></span>Command-Line Executable

Some components of the application will be replacable with command line
applications that take specific arguments and return a single result
(e.g Selectivities/Layers).

A specification will be developed to allow people to build and specify
stand-alone executable based plugins for specific functionality within
CASAL2 II.

The upside to this approach is that the user can specify any type of
executable they wish, developed in any language, including
shell-scripts. The application will simply do an exec() call on that
object and intepret the result.

*Difficulty for user to develop:* Low

*Execution speed:* Slow

## <span id="anchor-35"></span>Equation Parser

CASAL2 will have an inbuilt equation parser for handling equations
specified natively in the configuration file.

A valid example equation would be: 3^x \* 2

Where the user is able to bind 'x' to an internal parameter inside
CASAL2 II.

*Difficulty for user to develop:* Low

*Execution speed:* Slow

#

# <span id="anchor-36"></span>Population Processes

CASAL2 supports a number of population processes. While there is a large
number of individual processes the general purpose of these can be
broken down in to a few different types.

Category shifting, recruitment, mortality and ageing/growth.

## <span id="anchor-37"></span>Category Shifting

These processes are responsible for moving part of the population from 1
category in to another.

Implemented in CASAL2 there is:

  - Rate

## <span id="anchor-38"></span>Recruitment

These processes are responsible for the introduction of new population
members.

Implemented in CASAL2 there is:

  - Constant rate
  - Beverton-Holt

## <span id="anchor-39"></span>Mortality

These processes are responsible for the removal of population members.

Implemented in CASAL2 there is:

  - Constant rate
  - Event

## <span id="anchor-40"></span>Ageing/Growth

These processes are responsible for moving population members up through
ages/lengths. They work similar to category shifting except only work
within a single category.

Implemented in CASAL2 there is:

  - Ageing

# <span id="anchor-41"></span>Software Integrity

One of the key focusses in the CASAL2 development is the emphasis on
software integrity. It's hugely important to ensure results coming from
user models are consistent and correct.

As part of this we utilise unit tests to check individual components of
the software and run entire models verifying results.

CASAL2 uses:

  - Google testing framework
  - Google mocking framework

